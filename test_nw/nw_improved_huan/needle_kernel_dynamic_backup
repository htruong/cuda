#include <needle.h>
#include <stdio.h>
#include <cuda.h>

#define STRIDE_SIZE 256		// equal to the number of thread per block
#define PAIR_IN_BLOCK 32

__global__ void needleman_cuda_dynamic(char *sequence_set1, char *sequence_set2, 
									   unsigned int *pos1, unsigned int *pos2,
									   short *score_matrix, unsigned int *pos_matrix,
									   unsigned int max_pair_no, short penalty)
{ 
	__shared__ char s_seq1[PAIR_IN_BLOCK][STRIDE_SIZE+1];
	__shared__ short s_line1[PAIR_IN_BLOCK][STRIDE_SIZE+1];
	__shared__ short s_line2[PAIR_IN_BLOCK][STRIDE_SIZE+1];
	short *pl1, *pl2, *ptmp, *matrix;
	char seq2_ch, *seq1, *seq2;
	unsigned int start_pair_no = blockIdx.x * PAIR_IN_BLOCK;
	unsigned int end_pair_no = (blockIdx.x+1)*PAIR_IN_BLOCK<max_pair_no? (blockIdx.x+1)*PAIR_IN_BLOCK:max_pair_no; 
	unsigned int tid = threadIdx.x;
	unsigned int seq1_len = pos1[start_pair_no+1] - pos1[start_pair_no];
	unsigned int seq2_len;
	unsigned int stride = seq1_len / STRIDE_SIZE;
	int i, j, k, index_x, index_y;
	if ( (seq1_len % STRIDE_SIZE)!=0 ) stride++;
	
	if ( start_pair_no<end_pair_no ){
	// Divide the long array into different stride
	for (i=0; i<stride; ++i) {
		/************** Initialization **************/
		index_x = 0; index_y = tid + i*STRIDE_SIZE+1;
		/* Here, we should add a bunch of assignment statement */		
		for (j=start_pair_no; j<end_pair_no; ++j) {	// iteration between different loops
			if ( i==0 )	s_line1[j-start_pair_no][0] = *(score_matrix + pos_matrix[j]) = 0;
			else	s_line1[j-start_pair_no][0] = matrix[i*STRIDE_SIZE];
			if ( index_y<=seq1_len ) {			
				matrix = score_matrix + pos_matrix[j];
				matrix[index_y] = s_line1[j-start_pair_no][tid+1] = penalty * index_y;
				seq1 = sequence_set1 + pos1[j];
				s_seq1[j-start_pair_no][tid+1] = seq1[index_y-1];
			}
		}
		/**************************************/
		
		/************* fill the matrix **************/
		pl1 = s_line1[tid];
		pl2 = s_line2[tid];
		seq2_len = pos2[start_pair_no+1] - pos2[start_pair_no];
		for (index_x=1; index_x<=seq2_len; ++index_x){	// each iteration stands for each row
			if ( start_pair_no+tid<end_pair_no ) {		// seq2_len should be the maximum length
				seq2 = sequence_set2 + pos2[start_pair_no+tid];
				seq1_len = pos1[start_pair_no+tid+1] - pos1[start_pair_no+tid];	// length
				matrix = score_matrix + pos_matrix[start_pair_no+tid];
				index_y = i*STRIDE_SIZE+1;
				/************* Calculation **************/
				seq2_ch = seq2[index_x-1];
				if (i==0)  pl2[0] = matrix[index_x*(seq1_len+1)] = penalty * index_x;	// initialize the first column
				else pl2[0] = matrix[index_x*(seq1_len+1) + i*STRIDE_SIZE];			// load the data from last iteration
			
				for (k=0; k<STRIDE_SIZE; ++k) {
					pl2[1+k] = maximum(pl2[k]+penalty,		\
									   pl1[1+k]+penalty,	\
									   pl1[k]+blosum62[seq2_ch][s_seq1[tid][k+1]]);
				}
				/************* swap the pointer ****************/
				ptmp = pl1;	pl1 = pl2; pl2 = ptmp;
			}
			__syncthreads();
			/*********** store data to global memory **********/	
			index_y = tid + i*STRIDE_SIZE+1;		
			for (j=start_pair_no; j<end_pair_no; ++j) {
				if ( index_y<=seq1_len ) {		
					matrix = score_matrix + pos_matrix[j];				
					seq1_len = pos1[j+1] - pos1[j];		
					if ( index_x&1 == 1)
						matrix[index_x*(seq1_len+1)+index_y] = s_line2[j-start_pair_no][tid+1];
					else
						matrix[index_x*(seq1_len+1)+index_y] = s_line1[j-start_pair_no][tid+1];
				}
			}
			__syncthreads();		
		}
	}	//end of for
	}	//end of if
}
